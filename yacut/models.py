import re
from datetime import datetime
from random import choices

from settings import (
    MAX_LINK_LENGTH,
    MAX_LOOP_COUNT,
    EMPTY_ORIGINAL_LINK,
    REGEX_PATTERN,
    WRONG_SHORT_LINK_REGEX,
    LETTERS_FOR_SHORT_LINK,
    AUTOGENERATED_LENGTH,
)
from yacut import db
from yacut.error_handlers import APIError


class URLMap(db.Model):
    id = db.Column(
        db.Integer,
        primary_key=True
    )
    original = db.Column(
        db.String(),
        nullable=False,
        index=True
    )
    short = db.Column(
        db.String(MAX_LINK_LENGTH),
        index=True,
        unique=True
    )
    timestamp = db.Column(
        db.DateTime, default=datetime.utcnow
    )

    @staticmethod
    def check_api_short(original, short):
        """
        При попытке тут выбросить питоновский error и перехватить его в api_views,
        чтобы оттуда вызвать APIError не срабатывает, как я понимаю ошибка отсюда тоже вызывается
        и это происходит раньше, чем кастомная после перехвата
        models.py
        if not original:
            raise ValueError(EMPTY_ORIGINAL_LINK)

        api_views.pu
        ...
        try: URLMap.check_api_short(original, short)
        except ValueError as error:
            raise APIError(error)

        Тесты получают ValueError и падают, что от меня требуется и как это должно выглядеть без оглядки
        на тесты я понял, но чтобы проходили тесты не получается, возможно что-то упускаю.
        """
        if not original:
            raise APIError(EMPTY_ORIGINAL_LINK)
        if short:
            if len(short) > MAX_LINK_LENGTH:
                raise APIError(WRONG_SHORT_LINK_REGEX)
            if not re.match(REGEX_PATTERN, short):
                raise APIError(WRONG_SHORT_LINK_REGEX)

    @staticmethod
    def create_short_url():
        for _ in range(MAX_LOOP_COUNT):
            short_url = ''.join(
                choices(
                    LETTERS_FOR_SHORT_LINK,
                    k=AUTOGENERATED_LENGTH
                )
            )
            if not URLMap.get_link(short_url):
                return short_url
        raise ValueError('Не удалоось подобрать случайную ссылку')

    @staticmethod
    def add_link(original, short):
        if URLMap.get_link(short):
            return
        if not short:
            short = URLMap.create_short_url()
        url = URLMap(
            original=original,
            short=short
        )
        db.session.add(url)
        db.session.commit()
        return short

    @staticmethod
    def get_link(short):
        return (
            URLMap.query.filter_by(
                short=short
            ).first()
        )
